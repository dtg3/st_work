# Homework B: Viability Testing for TinyDB Conclusion
#### Drew Guarnera & Heather Michaud

A development team requires a database for a small store. The database could
have up to 1,000 customers with each customer having a purchase history of
approximately 500 items. For this task, the development team suggests the
python package [TinyDB](https://github.com/msiemens/tinydb) be used as the
document based database engine. The mission of the viability test is to assess
the potential of using TinyDB for the purposes of a small store customer
database.

### Procedure
The viability testing for the TinyDB database engine was performed using Python
version 3.5.0, TinyDB version 2.4, and ujson version 1.33 (for optimized json
support in TinyDB). Timing data was collected for all basic database operations
add new data (insert), modify existing data (update), delete data (remove). Each
of these operations are tested on a very small TinyDB database to verify that
the operations are possible to perform. These tests consist of a very basic
and streamlined version of a customer database featuring only two records at the
start of each test in the following format.

``` json
[
  {
    "customerid": 1,
    "items": [
      {"name": "raspberry pi", "price": 30},
      {"name": "pi case", "price": 8}
    ]
  }
]
```


These tests are repeated again on a very large TinyDB database containing more
complex mock customer, order, and item data like the example below to help
evaluate TinyDB's performance.

``` json
[
  {
    "cust_id": "3ae8a9f7-0f54-498b-8e89-b8fe7e43a8a9",
    "cust_name": "Fuelworks",
    "orders": [
      {
        "order_id": "d8a40a2b-facc-4d0a-8b0f-32a4e9d7080c",
        "order_date": "2014-05-08",
        "items": [
          {
            "item_id": "fce48268-0b4c-4fba-994f-03174ab9c9a0",
            "item_name": "dolor",
            "item_qty": 80,
            "item_cost": "$129.78"
          }
        ]
      }
    ]
  }
]
```

The mock dataset consists of 1,000 customer records each containing 50 orders
with each order holding 10 items each. This dataset was generated by
http://www.json-generator.com/ using the following generation script.

```
[
  '{{repeat(100)}}',
  {
    cust_id: '{{guid()}}',
    cust_name: '{{company()}}',
    orders: [
      '{{repeat(50)}}',
      {
        order_id: '{{guid()}}',
        order_date: '{{date(new Date(2014, 0, 1), new Date(), "YYYY-MM-dd")}}',
        items: [
          '{{repeat(10)}}',
          {
          item_id: '{{guid()}}',
          item_name: '{{lorem(1, "words")}}',
          item_qty:  '{{integer(1, 100)}}',
          item_cost: '{{floating(1, 200, 2, "$0.00")}}'
          }
          ]
      }
      ]
  }
 ]
```

This data set meets the proposed upper bound storage capacity required by the
development team and is all contained in one TinyDB table.

All of the operations on the database are tested and validated using the
internal Python unittest module, and timing data is stored in a separate csv to
assess the approximate latency of all the operations using the Python time
module. To help put both the timing performance and relative convenience of
operations of TinyDB into perspective, the sqlite3 python module was also used
in a mirrored set of tests against a large dataset. In an effort to make the
performance tests fair between sqlite3 and TinyDB, all the records are stored
flat in one table generated using the following SQL command.

``` sql
CREATE TABLE orders
(cust_id text, cust_name text, order_id text, order_date date, item_id text,
  item_name text, item_qty real, item_cost real)
```

The resulting sqlite3 table contains 500,000 records all populated with the same
data from the mock dataset. Since it is assumed that large databases will task
the respective engines (sqlite3 and TinyDB) more than small record sets, only
the large scale tests will be replicated with sqlite3 as a basis for comparison
between the two engines.

### Testing
The following section introduces the set of tests used to provide evidence of
TinyDB's viability as a database engine for a customer database. Since there are
17 tests for this viability test, the descriptions and results will be
grouped together by the activity or performance timing indicator. Each test
includes a basic description of the test itself, and the results of the test.
For simplicity, all mentions in the tests referring to a "small database" refers
to the simple data shown above, while "big database" refers to the large 1,000
customer record mock database. It should be noted that the small database and
big database tests are separate, but once again, for brevity and since they
cover similar operations they are both covered in the general test categories
below.

#### Add Record
This test is used to evaluate that sqlite3 and TinyDB are capable of adding a
new record to a dataset. Both the small database and big database add a single
customer record complete with items (and orders in the case of the big database)
to the database. This test corresponds specifically to the requirements:
*An element can be added to the database*
*Adding element takes less than 0.05 seconds*
*Add, view, and delete can be performed in less than one LOC*

When dealing with the small database, TinyDB was very capable of
adding a new customer record into a database and with a speedy performance
time of 0.0002 seconds. Additionally, the code required to make the change to
the database and can be done in one line of code. However when it came to
running the add record test on the big database, the insertion time for TinyDb
increased drastically to 3.7235 seconds. For the sqlite3 version of this both
the inserts for the big database only took 0.0007 and only required one
additional line of code (two total) to "commit" the change to the database.

#### Add Item to Record
This test attempts to add existing data content to an existing record. For
example, adding another item, or order, to an existing customer record. Both the
small and big database add an item to a customer record, while the big database
additionally adds a new order (including items) into a customer record. This
test corresponds specifically to the requirements:
*An element can be added to an item within the database*
*Adding element takes less than 0.05 seconds*
*Add, view, and delete can be performed in less than one LOC*

TinyDB handled the small database item took only 0.0001 seconds to execute and
four lines of code. The big database test took significantly longer with
addition of a new item required 4.0842 seconds and adding an order to the
customer record (items included) took 5.5983 seconds. The lines of code also
increased to eleven lines for the item addition and four lines of code for the
order addition. The sqlite version is able to add an item to a record in
the big database in only 0.0007 seconds while still only requiring only two
lines of code.

#### 
