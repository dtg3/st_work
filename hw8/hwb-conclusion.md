# Homework B: Viability Testing for TinyDB Conclusion
#### Drew Guarnera & Heather Michaud

A development team requires a database for a small store. The database could
have up to 1,000 customers with each customer having a purchase history of
approximately 500 items. For this task, the development team suggests the
python package [TinyDB](https://github.com/msiemens/tinydb) be used as the
document based database engine. The mission of the viability test is to assess
the potential of using TinyDB for the purposes of a small store customer
database.

### Procedure
The viability testing for the TinyDB database engine was performed using Python
version 3.5.0, TinyDB version 2.4, and ujson version 1.33 (for optimized json
support in TinyDB). Timing data was collected for all basic database operations
add new data (insert), modify existing data (update), delete data (remove). Each
of these operations are tested on a very small TinyDB database to verify that
the operations are possible to perform. These tests consist of a very basic
and streamlined version of a customer database featuring only two records at the
start of each test in the following format.

``` json
[
  {
    "customerid": 1,
    "items": [
      {"name": "raspberry pi", "price": 30},
      {"name": "pi case", "price": 8}
    ]
  }
]
```


These tests are repeated again on a very large TinyDB database containing more
complex mock customer, order, and item data like the example below to help
evaluate TinyDB's performace.

``` json
[
  {
    "cust_id": "3ae8a9f7-0f54-498b-8e89-b8fe7e43a8a9",
    "cust_name": "Fuelworks",
    "orders": [
      {
        "order_id": "d8a40a2b-facc-4d0a-8b0f-32a4e9d7080c",
        "order_date": "2014-05-08",
        "items": [
          {
            "item_id": "fce48268-0b4c-4fba-994f-03174ab9c9a0",
            "item_name": "dolor",
            "item_qty": 80,
            "item_cost": "$129.78"
          }
        ]
      }
    ]
  }
]
```

The mock dataset consists of 1,000 customer records each containing 50 orders
with each order holding 10 items each. This dataset was generated by
http://www.json-generator.com/ using the following generation script.

```
[
  '{{repeat(100)}}',
  {
    cust_id: '{{guid()}}',
    cust_name: '{{company()}}',
    orders: [
      '{{repeat(50)}}',
      {
        order_id: '{{guid()}}',
        order_date: '{{date(new Date(2014, 0, 1), new Date(), "YYYY-MM-dd")}}',
        items: [
          '{{repeat(10)}}',
          {
          item_id: '{{guid()}}',
          item_name: '{{lorem(1, "words")}}',
          item_qty:  '{{integer(1, 100)}}',
          item_cost: '{{floating(1, 200, 2, "$0.00")}}'
          }
          ]
      }
      ]
  }
 ]
```

This data set meets the proposed upper bound storage capacity required by the
development team and is all contained in one TinyDB table.

All of the operations on the database are tested and validated using the
internal Python unittest module, and timing data is stored in a separate csv to
assess the approximate latency of all the operations using the Python time
module. To help put both the timing performance and relative convenience of
operations of TinyDB into perspective, the sqlite3 python module was also used
in a mirrored set of tests against a large dataset. In an effort to make the
performance tests fair between sqlite3 and TinyDB, all the records are stored
flat in one table generated using the following SQL command.

``` sql
CREATE TABLE orders
(cust_id text, cust_name text, order_id text, order_date date, item_id text,
  item_name text, item_qty real, item_cost real)
```

The resulting sqlite3 table contains 500,000 records all populated with the same
data from the mock dataset. Since it is assumed that large databases will task
the respective engines (sqlite3 and TinyDB) more than small record sets, only
the large scale tests will be replicated with sqlite3 as a basis for comparison
between the two engines.

### Testing
The following section introduces the set of tests used to provide evidence of
TinyDB's viability as a database engine as a customer database. Since the total
number of tests 

Each test
includes a basic description of the test itself, and the results of the test.
For simplicity, all mentions in the tests referring to a "small database" refers
to the simple data shown above, while "big database" refers to the large 1,000
mock customer database. It should be noted that the small database and big
database tests are separate, but for brevity since the cover similar operations
they are both covered in the test categories below. Additionally each test name
is prepended with the name of the database engine used in the test and TinyDB
tests are explained and evaluated separately from sqlite3 tests.

#### TinyDB Add Record
This test is used to evaluate that TinyDB is capable of adding a new record to a
dataset. Both the small database and big database have a single customer record
complete with items (and orders in the case of the big database) added to the
database. This test corresponds specifically to the requirements:
*An element can be added to the database*
*Adding element takes less than 0.05 seconds*

When dealing with the small database, TinyDB was very capable of
inserting a new customer record into a database and with a speedy performance
time of 0.0002 seconds. Additionally, the code required to iHowever, for the big database




### Requirements
In order to determine if TinyDB is viable for this purpose, we first define a
set of database actions which we wish to perform for the small store:
  - Add a customer
  - Add an item purchased to a customer's 'tab'
  - Add multiple instances of the same item purchased to the same customer
  - Delete a customer
  - Delete an item from a customer
  - View a customer and the items they have purchased
  - Determine which items are bought most frequently
  - Determine which items have been bought least frequently
  - Determine the type preference of a customer based on previous item choices
  - The database must be capable of containing 500,000 records

The addition, deletion, and viewing of the data for a particular customer or
item is crucial for any basic database operations. We expand further upon these
requirements by specifying that each of the following requirements must also be
met, provided a maximal database of 1,000 customers, each with 500 items:
  - Add customer/item takes less than 0.05 seconds
  - Deleting a customer/item takes less than 0.1 seconds
  - Accessing a customer/item takes less than 0.01 seconds

We expect the most frequent operation that is performed is the accessing of
data within the database for frequently item set mining and other operations to
improve the customer experience, so fast access to the data is critical. As
we only expect to have 1,000 customers, additions to the database will be less
frequent though still relevant. Finally, the deletion of customers or items is
expected to happen least frequently so the performance for that is least
important.

We also want the API to be easy to use and clean. As this is subjective, we
define 'easy to use' such that the API has documentation and examples of each
operation we wish to perform. We define 'clean' such that basic operations
(add, view, delete) can be performed in one line of code.


### Test plan & methodology
We use viability testing to assess whether TinyDB is suitable for the task at
hand. We narrow down this list to a set of 10 functional and non-functional
requirements. The most commonly used functionality includes adding, deleting,
and viewing an item from the database. The most important non-functional
requirements are those of a clean design and computationally efficient
performance. Thus our specific tests involve verifying the following:
  1. An element can be added to the database
  1. An element can be added to an item within the database
  1. An element can be removed from any location within the database
  1. An element can be retrieved from the database
  1. A TinyDB can consist of 1,000 elements which have 500 sub-elements
  1. Adding element takes less than 0.05 seconds
  1. Deleting an element takes less than .1 seconds
  1. Accessing an element takes less than 0.01 seconds
  1. Documentation exists and is easily accessible and thorough
  1. Add, view, and delete can be performed in less than one LOC

To accomplish these testing tasks, python and TinyDB are used primarily. Timing
performance is compared to that of SQLite. For the last two requirements,
manual verification is used.
